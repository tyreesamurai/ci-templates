name: reusable-build-and-deploy
on:
  workflow_call:
    inputs:
      image_name:
        description: "GHCR image (owner/name)"
        required: true
        type: string
      context:
        description: "Docker build context folder (contains Dockerfile)"
        required: false
        type: string
        default: "."
      dockerfile:
        description: "Dockerfile path (relative to context)"
        required: false
        type: string
        default: "Dockerfile"
      build_args:
        description: "Extra build args (KEY=VAL, space-separated)"
        required: false
        type: string
        default: ""
      namespace:
        description: "Kubernetes namespace of the Deployment"
        required: true
        type: string
      deployment:
        description: "Kubernetes Deployment name to restart"
        required: true
        type: string
      secret_name:
        description: "Kubernetes secret name to create from ENV_FILE"
        required: false
        type: string
        default: "app-env"
      kube_context:
        description: "kubectl context on the server"
        required: false
        type: string
        default: "k3d-home"
    secrets:
      DEPLOY_HOST: { required: true }
      DEPLOY_KEY: { required: true }
      TS_AUTHKEY: { required: true }
      ENV_FILE: { required: false }

env:
  REGISTRY: ghcr.io

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    steps:
      - uses: actions/checkout@v4

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build, Tag & Push
        run: |
          set -euo pipefail
          CTX="${{ inputs.context }}"
          DF="Dockerfile"

          # Optional build args
          EXTRA_ARGS=""
          if [ -n "${{ inputs.build_args }}" ]; then
            for kv in ${{ inputs.build_args }}; do
              EXTRA_ARGS="$EXTRA_ARGS --build-arg $kv"
            done
          fi

          echo "=> ls of context:"
          ls -la "$CTX"

          # Sanity checks
          [ -d "$CTX" ] || { echo "Build context not found: $CTX" >&2; exit 1; }
          [ -f "$CTX/$DF" ] || { echo "Dockerfile not found: $CTX/$DF" >&2; exit 1; }

          echo "=> Building $REGISTRY/${{ inputs.image_name }}:$GITHUB_SHA"
          docker build \
            -f "$CTX/$DF" \
            $EXTRA_ARGS \
            -t "$REGISTRY/${{ inputs.image_name }}:$GITHUB_SHA" \
            "$CTX"

          docker tag "$REGISTRY/${{ inputs.image_name }}:$GITHUB_SHA" \
                    "$REGISTRY/${{ inputs.image_name }}:latest"

          docker push $REGISTRY/${{ inputs.image_name }}:$GITHUB_SHA
          docker push $REGISTRY/${{ inputs.image_name }}:latest

      - name: Start Tailscale
        uses: tailscale/github-action@v2
        with:
          authkey: ${{ secrets.TS_AUTHKEY }}

      - name: Prepare SSH
        run: |
          mkdir -p ~/.ssh && chmod 700 ~/.ssh
          umask 177
          cat > key.pem <<'KEY'
          ${{ secrets.DEPLOY_KEY }}
          KEY
          ssh-keyscan -T 10 ${{ secrets.DEPLOY_HOST }} >> ~/.ssh/known_hosts
          chmod 644 ~/.ssh/known_hosts

      - name: Apply Kubernetes secret from .env (optional)
        uses: appleboy/ssh-action@v1.2.0
        env:
          ENV_FILE: ${{ secrets.ENV_FILE }}
          SECRET_NAME: ${{ inputs.secret_name || 'app-env' }}
        with:
          host: ${{ secrets.DEPLOY_HOST }}
          username: deploy
          key_path: key.pem
          script_stop: true
          debug: true
          script: |
            set -euo pipefail
            kubectl config use-context "${{ inputs.kube_context }}" || true

            if [ -z "${ENV_FILE:-}" ]; then
              echo "No ENV_FILE provided; skipping secret creation."
              exit 0
            fi

            tmpfile=$(mktemp)
            cat > "$tmpfile" <<'ENVEOF'
            ${{ secrets.ENV_FILE }}
            ENVEOF

            kubectl -n "${{ inputs.namespace }}" create secret generic "${{ inputs.secret_name }}" \
              --from-env-file="$tmpfile" \
              --dry-run=client -o yaml | kubectl apply -f -

            rm -f "$tmpfile"

      - name: Rollout restart on cluster
        uses: appleboy/ssh-action@v1.2.0
        with:
          host: ${{ secrets.DEPLOY_HOST }}
          username: deploy
          key_path: key.pem
          script_stop: true
          debug: true
          script: |
            set -euo pipefail
            kubectl config use-context "${{ inputs.kube_context }}" || true

            echo "Current images:"
            kubectl -n "${{ inputs.namespace }}" get pods -l app=${{ inputs.deployment }} -o jsonpath='{range .items[*]}{.metadata.name}{" -> "}{.spec.containers[*].image}{"\n"}{end}' || true

            # Restart the deployment so it pulls :latest (ensure your Deployment uses imagePullPolicy: Always)
            kubectl -n "${{ inputs.namespace }}" rollout restart deploy/${{ inputs.deployment }}

            # Wait for it to become Ready
            kubectl -n "${{ inputs.namespace }}" rollout status deploy/${{ inputs.deployment }} --timeout=180s

            # (Optional) show the new image IDs
            echo "New images:"
            kubectl -n "${{ inputs.namespace }}" get pods -l app=${{ inputs.deployment }} -o jsonpath='{range .items[*]}{.metadata.name}{" -> "}{range .status.containerStatuses[*]}{.imageID}{" "}{end}{"\n"}{end}' || true
